// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v6.30.2
// source: codewiki/v1/codewiki.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationCodeWikiServiceAnalyzeRepo = "/codewiki.v1.CodeWikiService/AnalyzeRepo"
const OperationCodeWikiServiceCallChain = "/codewiki.v1.CodeWikiService/CallChain"
const OperationCodeWikiServiceCreateRepo = "/codewiki.v1.CodeWikiService/CreateRepo"
const OperationCodeWikiServiceDeleteRepo = "/codewiki.v1.CodeWikiService/DeleteRepo"
const OperationCodeWikiServiceGetImplement = "/codewiki.v1.CodeWikiService/GetImplement"
const OperationCodeWikiServiceGetRepo = "/codewiki.v1.CodeWikiService/GetRepo"
const OperationCodeWikiServiceGetRepoTree = "/codewiki.v1.CodeWikiService/GetRepoTree"
const OperationCodeWikiServiceListRepos = "/codewiki.v1.CodeWikiService/ListRepos"
const OperationCodeWikiServiceViewFileContent = "/codewiki.v1.CodeWikiService/ViewFileContent"

type CodeWikiServiceHTTPServer interface {
	// AnalyzeRepo Analyze by repository id
	AnalyzeRepo(context.Context, *AnalyzeRepoReq) (*AnalyzeResp, error)
	CallChain(context.Context, *CallChainReq) (*CallChainResp, error)
	// CreateRepo Repo management
	CreateRepo(context.Context, *CreateRepoReq) (*CreateRepoResp, error)
	DeleteRepo(context.Context, *DeleteRepoReq) (*DeleteRepoResp, error)
	// GetImplement interface  implement
	GetImplement(context.Context, *GetImplementReq) (*GetImplementResp, error)
	GetRepo(context.Context, *GetRepoReq) (*GetRepoResp, error)
	// GetRepoTree Repo tree display
	GetRepoTree(context.Context, *GetRepoTreeReq) (*GetRepoTreeResp, error)
	ListRepos(context.Context, *ListReposReq) (*ListReposResp, error)
	// ViewFileContent File  view  content
	ViewFileContent(context.Context, *ViewFileReq) (*ViewFileResp, error)
}

func RegisterCodeWikiServiceHTTPServer(s *http.Server, srv CodeWikiServiceHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/api/functions/{id}/calls", _CodeWikiService_CallChain0_HTTP_Handler(srv))
	r.POST("/v1/api/repos", _CodeWikiService_CreateRepo0_HTTP_Handler(srv))
	r.GET("/v1/api/repos", _CodeWikiService_ListRepos0_HTTP_Handler(srv))
	r.GET("/v1/api/repos/{id}", _CodeWikiService_GetRepo0_HTTP_Handler(srv))
	r.DELETE("/v1/api/repos/{id}", _CodeWikiService_DeleteRepo0_HTTP_Handler(srv))
	r.POST("/v1/api/repos/{id}/analyze", _CodeWikiService_AnalyzeRepo0_HTTP_Handler(srv))
	r.GET("/v1/api/repos/{id}/tree", _CodeWikiService_GetRepoTree0_HTTP_Handler(srv))
	r.GET("/v1/api/{repoId}/file/{id}/view", _CodeWikiService_ViewFileContent0_HTTP_Handler(srv))
	r.GET("/v1/api/entity/{id}/implements", _CodeWikiService_GetImplement0_HTTP_Handler(srv))
}

func _CodeWikiService_CallChain0_HTTP_Handler(srv CodeWikiServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CallChainReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeWikiServiceCallChain)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CallChain(ctx, req.(*CallChainReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CallChainResp)
		return ctx.Result(200, reply)
	}
}

func _CodeWikiService_CreateRepo0_HTTP_Handler(srv CodeWikiServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateRepoReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeWikiServiceCreateRepo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateRepo(ctx, req.(*CreateRepoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateRepoResp)
		return ctx.Result(200, reply)
	}
}

func _CodeWikiService_ListRepos0_HTTP_Handler(srv CodeWikiServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListReposReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeWikiServiceListRepos)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListRepos(ctx, req.(*ListReposReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListReposResp)
		return ctx.Result(200, reply)
	}
}

func _CodeWikiService_GetRepo0_HTTP_Handler(srv CodeWikiServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetRepoReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeWikiServiceGetRepo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetRepo(ctx, req.(*GetRepoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetRepoResp)
		return ctx.Result(200, reply)
	}
}

func _CodeWikiService_DeleteRepo0_HTTP_Handler(srv CodeWikiServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteRepoReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeWikiServiceDeleteRepo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteRepo(ctx, req.(*DeleteRepoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteRepoResp)
		return ctx.Result(200, reply)
	}
}

func _CodeWikiService_AnalyzeRepo0_HTTP_Handler(srv CodeWikiServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AnalyzeRepoReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeWikiServiceAnalyzeRepo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AnalyzeRepo(ctx, req.(*AnalyzeRepoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AnalyzeResp)
		return ctx.Result(200, reply)
	}
}

func _CodeWikiService_GetRepoTree0_HTTP_Handler(srv CodeWikiServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetRepoTreeReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeWikiServiceGetRepoTree)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetRepoTree(ctx, req.(*GetRepoTreeReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetRepoTreeResp)
		return ctx.Result(200, reply)
	}
}

func _CodeWikiService_ViewFileContent0_HTTP_Handler(srv CodeWikiServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ViewFileReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeWikiServiceViewFileContent)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ViewFileContent(ctx, req.(*ViewFileReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ViewFileResp)
		return ctx.Result(200, reply)
	}
}

func _CodeWikiService_GetImplement0_HTTP_Handler(srv CodeWikiServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetImplementReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeWikiServiceGetImplement)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetImplement(ctx, req.(*GetImplementReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetImplementResp)
		return ctx.Result(200, reply)
	}
}

type CodeWikiServiceHTTPClient interface {
	AnalyzeRepo(ctx context.Context, req *AnalyzeRepoReq, opts ...http.CallOption) (rsp *AnalyzeResp, err error)
	CallChain(ctx context.Context, req *CallChainReq, opts ...http.CallOption) (rsp *CallChainResp, err error)
	CreateRepo(ctx context.Context, req *CreateRepoReq, opts ...http.CallOption) (rsp *CreateRepoResp, err error)
	DeleteRepo(ctx context.Context, req *DeleteRepoReq, opts ...http.CallOption) (rsp *DeleteRepoResp, err error)
	GetImplement(ctx context.Context, req *GetImplementReq, opts ...http.CallOption) (rsp *GetImplementResp, err error)
	GetRepo(ctx context.Context, req *GetRepoReq, opts ...http.CallOption) (rsp *GetRepoResp, err error)
	GetRepoTree(ctx context.Context, req *GetRepoTreeReq, opts ...http.CallOption) (rsp *GetRepoTreeResp, err error)
	ListRepos(ctx context.Context, req *ListReposReq, opts ...http.CallOption) (rsp *ListReposResp, err error)
	ViewFileContent(ctx context.Context, req *ViewFileReq, opts ...http.CallOption) (rsp *ViewFileResp, err error)
}

type CodeWikiServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewCodeWikiServiceHTTPClient(client *http.Client) CodeWikiServiceHTTPClient {
	return &CodeWikiServiceHTTPClientImpl{client}
}

func (c *CodeWikiServiceHTTPClientImpl) AnalyzeRepo(ctx context.Context, in *AnalyzeRepoReq, opts ...http.CallOption) (*AnalyzeResp, error) {
	var out AnalyzeResp
	pattern := "/v1/api/repos/{id}/analyze"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCodeWikiServiceAnalyzeRepo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeWikiServiceHTTPClientImpl) CallChain(ctx context.Context, in *CallChainReq, opts ...http.CallOption) (*CallChainResp, error) {
	var out CallChainResp
	pattern := "/v1/api/functions/{id}/calls"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCodeWikiServiceCallChain))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeWikiServiceHTTPClientImpl) CreateRepo(ctx context.Context, in *CreateRepoReq, opts ...http.CallOption) (*CreateRepoResp, error) {
	var out CreateRepoResp
	pattern := "/v1/api/repos"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCodeWikiServiceCreateRepo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeWikiServiceHTTPClientImpl) DeleteRepo(ctx context.Context, in *DeleteRepoReq, opts ...http.CallOption) (*DeleteRepoResp, error) {
	var out DeleteRepoResp
	pattern := "/v1/api/repos/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCodeWikiServiceDeleteRepo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeWikiServiceHTTPClientImpl) GetImplement(ctx context.Context, in *GetImplementReq, opts ...http.CallOption) (*GetImplementResp, error) {
	var out GetImplementResp
	pattern := "/v1/api/entity/{id}/implements"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCodeWikiServiceGetImplement))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeWikiServiceHTTPClientImpl) GetRepo(ctx context.Context, in *GetRepoReq, opts ...http.CallOption) (*GetRepoResp, error) {
	var out GetRepoResp
	pattern := "/v1/api/repos/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCodeWikiServiceGetRepo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeWikiServiceHTTPClientImpl) GetRepoTree(ctx context.Context, in *GetRepoTreeReq, opts ...http.CallOption) (*GetRepoTreeResp, error) {
	var out GetRepoTreeResp
	pattern := "/v1/api/repos/{id}/tree"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCodeWikiServiceGetRepoTree))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeWikiServiceHTTPClientImpl) ListRepos(ctx context.Context, in *ListReposReq, opts ...http.CallOption) (*ListReposResp, error) {
	var out ListReposResp
	pattern := "/v1/api/repos"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCodeWikiServiceListRepos))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeWikiServiceHTTPClientImpl) ViewFileContent(ctx context.Context, in *ViewFileReq, opts ...http.CallOption) (*ViewFileResp, error) {
	var out ViewFileResp
	pattern := "/v1/api/{repoId}/file/{id}/view"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCodeWikiServiceViewFileContent))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
