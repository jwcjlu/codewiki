// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v6.30.2
// source: codewiki/v1/codewiki.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationRepoServiceCreateRepo = "/codewiki.v1.RepoService/CreateRepo"
const OperationRepoServiceDeleteRepo = "/codewiki.v1.RepoService/DeleteRepo"
const OperationRepoServiceGetRepo = "/codewiki.v1.RepoService/GetRepo"
const OperationRepoServiceGetRepoTree = "/codewiki.v1.RepoService/GetRepoTree"
const OperationRepoServiceListRepos = "/codewiki.v1.RepoService/ListRepos"

type RepoServiceHTTPServer interface {
	// CreateRepo Repo management
	CreateRepo(context.Context, *CreateRepoReq) (*CreateRepoResp, error)
	DeleteRepo(context.Context, *DeleteRepoReq) (*DeleteRepoResp, error)
	GetRepo(context.Context, *GetRepoReq) (*GetRepoResp, error)
	// GetRepoTree Repo tree display
	GetRepoTree(context.Context, *GetRepoTreeReq) (*GetRepoTreeResp, error)
	ListRepos(context.Context, *ListRepoReq) (*ListRepoResp, error)
}

func RegisterRepoServiceHTTPServer(s *http.Server, srv RepoServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/api/repo", _RepoService_CreateRepo0_HTTP_Handler(srv))
	r.GET("/v1/api/repos", _RepoService_ListRepos0_HTTP_Handler(srv))
	r.GET("/v1/api/repo/{id}", _RepoService_GetRepo0_HTTP_Handler(srv))
	r.DELETE("/v1/api/repo/{id}", _RepoService_DeleteRepo0_HTTP_Handler(srv))
	r.GET("/v1/api/repos/{id}/tree", _RepoService_GetRepoTree0_HTTP_Handler(srv))
}

func _RepoService_CreateRepo0_HTTP_Handler(srv RepoServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateRepoReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationRepoServiceCreateRepo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateRepo(ctx, req.(*CreateRepoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateRepoResp)
		return ctx.Result(200, reply)
	}
}

func _RepoService_ListRepos0_HTTP_Handler(srv RepoServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListRepoReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationRepoServiceListRepos)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListRepos(ctx, req.(*ListRepoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListRepoResp)
		return ctx.Result(200, reply)
	}
}

func _RepoService_GetRepo0_HTTP_Handler(srv RepoServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetRepoReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationRepoServiceGetRepo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetRepo(ctx, req.(*GetRepoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetRepoResp)
		return ctx.Result(200, reply)
	}
}

func _RepoService_DeleteRepo0_HTTP_Handler(srv RepoServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteRepoReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationRepoServiceDeleteRepo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteRepo(ctx, req.(*DeleteRepoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteRepoResp)
		return ctx.Result(200, reply)
	}
}

func _RepoService_GetRepoTree0_HTTP_Handler(srv RepoServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetRepoTreeReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationRepoServiceGetRepoTree)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetRepoTree(ctx, req.(*GetRepoTreeReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetRepoTreeResp)
		return ctx.Result(200, reply)
	}
}

type RepoServiceHTTPClient interface {
	CreateRepo(ctx context.Context, req *CreateRepoReq, opts ...http.CallOption) (rsp *CreateRepoResp, err error)
	DeleteRepo(ctx context.Context, req *DeleteRepoReq, opts ...http.CallOption) (rsp *DeleteRepoResp, err error)
	GetRepo(ctx context.Context, req *GetRepoReq, opts ...http.CallOption) (rsp *GetRepoResp, err error)
	GetRepoTree(ctx context.Context, req *GetRepoTreeReq, opts ...http.CallOption) (rsp *GetRepoTreeResp, err error)
	ListRepos(ctx context.Context, req *ListRepoReq, opts ...http.CallOption) (rsp *ListRepoResp, err error)
}

type RepoServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewRepoServiceHTTPClient(client *http.Client) RepoServiceHTTPClient {
	return &RepoServiceHTTPClientImpl{client}
}

func (c *RepoServiceHTTPClientImpl) CreateRepo(ctx context.Context, in *CreateRepoReq, opts ...http.CallOption) (*CreateRepoResp, error) {
	var out CreateRepoResp
	pattern := "/v1/api/repo"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationRepoServiceCreateRepo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *RepoServiceHTTPClientImpl) DeleteRepo(ctx context.Context, in *DeleteRepoReq, opts ...http.CallOption) (*DeleteRepoResp, error) {
	var out DeleteRepoResp
	pattern := "/v1/api/repo/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationRepoServiceDeleteRepo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *RepoServiceHTTPClientImpl) GetRepo(ctx context.Context, in *GetRepoReq, opts ...http.CallOption) (*GetRepoResp, error) {
	var out GetRepoResp
	pattern := "/v1/api/repo/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationRepoServiceGetRepo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *RepoServiceHTTPClientImpl) GetRepoTree(ctx context.Context, in *GetRepoTreeReq, opts ...http.CallOption) (*GetRepoTreeResp, error) {
	var out GetRepoTreeResp
	pattern := "/v1/api/repos/{id}/tree"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationRepoServiceGetRepoTree))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *RepoServiceHTTPClientImpl) ListRepos(ctx context.Context, in *ListRepoReq, opts ...http.CallOption) (*ListRepoResp, error) {
	var out ListRepoResp
	pattern := "/v1/api/repos"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationRepoServiceListRepos))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

const OperationCodeAnalyzerServiceAnalyzeRepo = "/codewiki.v1.CodeAnalyzerService/AnalyzeRepo"
const OperationCodeAnalyzerServiceCallChain = "/codewiki.v1.CodeAnalyzerService/CallChain"
const OperationCodeAnalyzerServiceGetImplement = "/codewiki.v1.CodeAnalyzerService/GetImplement"
const OperationCodeAnalyzerServiceViewFileContent = "/codewiki.v1.CodeAnalyzerService/ViewFileContent"

type CodeAnalyzerServiceHTTPServer interface {
	// AnalyzeRepo Analyze by repository id
	AnalyzeRepo(context.Context, *AnalyzeRepoReq) (*AnalyzeResp, error)
	CallChain(context.Context, *CallChainReq) (*CallChainResp, error)
	// GetImplement interface  implement
	GetImplement(context.Context, *GetImplementReq) (*GetImplementResp, error)
	// ViewFileContent File  view  content
	ViewFileContent(context.Context, *ViewFileReq) (*ViewFileResp, error)
}

func RegisterCodeAnalyzerServiceHTTPServer(s *http.Server, srv CodeAnalyzerServiceHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/api/functions/{id}/calls", _CodeAnalyzerService_CallChain0_HTTP_Handler(srv))
	r.POST("/v1/api/repos/{id}/analyze", _CodeAnalyzerService_AnalyzeRepo0_HTTP_Handler(srv))
	r.GET("/v1/api/{repoId}/file/{id}/view", _CodeAnalyzerService_ViewFileContent0_HTTP_Handler(srv))
	r.GET("/v1/api/entity/{id}/implements", _CodeAnalyzerService_GetImplement0_HTTP_Handler(srv))
}

func _CodeAnalyzerService_CallChain0_HTTP_Handler(srv CodeAnalyzerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CallChainReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeAnalyzerServiceCallChain)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CallChain(ctx, req.(*CallChainReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CallChainResp)
		return ctx.Result(200, reply)
	}
}

func _CodeAnalyzerService_AnalyzeRepo0_HTTP_Handler(srv CodeAnalyzerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AnalyzeRepoReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeAnalyzerServiceAnalyzeRepo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AnalyzeRepo(ctx, req.(*AnalyzeRepoReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AnalyzeResp)
		return ctx.Result(200, reply)
	}
}

func _CodeAnalyzerService_ViewFileContent0_HTTP_Handler(srv CodeAnalyzerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ViewFileReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeAnalyzerServiceViewFileContent)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ViewFileContent(ctx, req.(*ViewFileReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ViewFileResp)
		return ctx.Result(200, reply)
	}
}

func _CodeAnalyzerService_GetImplement0_HTTP_Handler(srv CodeAnalyzerServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetImplementReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCodeAnalyzerServiceGetImplement)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetImplement(ctx, req.(*GetImplementReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetImplementResp)
		return ctx.Result(200, reply)
	}
}

type CodeAnalyzerServiceHTTPClient interface {
	AnalyzeRepo(ctx context.Context, req *AnalyzeRepoReq, opts ...http.CallOption) (rsp *AnalyzeResp, err error)
	CallChain(ctx context.Context, req *CallChainReq, opts ...http.CallOption) (rsp *CallChainResp, err error)
	GetImplement(ctx context.Context, req *GetImplementReq, opts ...http.CallOption) (rsp *GetImplementResp, err error)
	ViewFileContent(ctx context.Context, req *ViewFileReq, opts ...http.CallOption) (rsp *ViewFileResp, err error)
}

type CodeAnalyzerServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewCodeAnalyzerServiceHTTPClient(client *http.Client) CodeAnalyzerServiceHTTPClient {
	return &CodeAnalyzerServiceHTTPClientImpl{client}
}

func (c *CodeAnalyzerServiceHTTPClientImpl) AnalyzeRepo(ctx context.Context, in *AnalyzeRepoReq, opts ...http.CallOption) (*AnalyzeResp, error) {
	var out AnalyzeResp
	pattern := "/v1/api/repos/{id}/analyze"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCodeAnalyzerServiceAnalyzeRepo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeAnalyzerServiceHTTPClientImpl) CallChain(ctx context.Context, in *CallChainReq, opts ...http.CallOption) (*CallChainResp, error) {
	var out CallChainResp
	pattern := "/v1/api/functions/{id}/calls"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCodeAnalyzerServiceCallChain))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeAnalyzerServiceHTTPClientImpl) GetImplement(ctx context.Context, in *GetImplementReq, opts ...http.CallOption) (*GetImplementResp, error) {
	var out GetImplementResp
	pattern := "/v1/api/entity/{id}/implements"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCodeAnalyzerServiceGetImplement))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CodeAnalyzerServiceHTTPClientImpl) ViewFileContent(ctx context.Context, in *ViewFileReq, opts ...http.CallOption) (*ViewFileResp, error) {
	var out ViewFileResp
	pattern := "/v1/api/{repoId}/file/{id}/view"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCodeAnalyzerServiceViewFileContent))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
